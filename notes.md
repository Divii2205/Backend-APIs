# Client Server Architecture:

**Client**: Requests for some services
**Server**: Provides the services; does only computation, and not store; storing is done by the database
**API**: 
* Client is ready to accept services, server is ready to provide the service and this transfer/supply of service happens through APIs. API is written/generated by the server/backend creator who generates the services.
* Application Programming Interface: Application must be programmed and processed and sent to the client through an interface which is called API. API can be server to server, client to client, client to server. It is a bridge for software systems to interact with each other.

## How backend processes requests:

Parts of url:
protocol -> domain name -> resource -> query

# Protocols: 
A set of rules and methodolagies followed during the service transfer, when API request is sent. To govern the service/data (govern the communication)

**Types:**

1. *TCP/IP* 
* Transmission Control Protocol: Controls the transmission of data; reliability and low speed
* Internet Protocol: How the transmission of data must take place

2. *HTTP/HTTPS*
* Hyper Text Transmission Protocol: Allows web communication
* Hyper Text Transmission Protocol Secure: Provides transport layer security through encryption

3. *UDP*
* User Datagram Protocol: High speed and less reliability; the TCP constantly keeps checking for errors during transmission to avoid any problems hence has a low speed and high reliability; UDP tackles this. In case some data packets are lost during transmission, send request again. Used in video calls, real time data, where user compromises on quality. 

4. *FTP*
* File Transfer Protocol: Assists in the transfer of files. 

5. *QUIC*
* Quick UDP Internet Connections: Improves the performance and security of web applications, developed by Google to replace Transmission Control Protocol 

**Netowork calls are the most expensive calls: repeated connection requests, time consuming**

## Network Protocol:

1. Data packing
2. Error handling
3. Routing
4. Flow control

NDA: Non discolsure agreement

## Streaming and SSE:

Transmitting data continuously over the internet, instead of downloading the entire file before playback
To and Fro of data packets => streaming
Client sends a request to the server, server sends request to the *storage*, server receives it and through TCP it reaches the client

### Types of streamings:

1. Progressive: Allows playback after buffering
2. Adaptive: provides option for quality
3. Real-time: Live broadcast and stock trading

**SSE**: *Server-sent Events*
Example: Push notification, when there is a change in the storage, a server sends a notification => SSE
*Unidirectional Communication*

# API:
## Components of API:
1. End points & Resources
2. HTTP methods & verbs
3. Data formats: Raw data/compiled data/processed data => plan txt, video, audio, image
4. Versioning: Keep the older versions of the API still active and compatible instead of depricating the entire API Key

### Why API? 

1. Scalability: multiple end points can be generated for the same API
2. Modularity: Even if one link/task fails, the remaining continue
3. Flexibility & Reusibility
4. Third-party Integration

## HTTP Methods:
1. GET
2. POST
3. DELETE
4. PUT
5. PATCH

**OPEN API => NO authorisation is required**

## Monolithic Architecture:
Software design model where all components of an application are built into a single unit. Any flaw in the service disrupts the entire architecture and destroys the entire server. Easy deployment, less cost and fast services.

## Microservices Architecture:
Multiple components where one server handles only one service. Servicing never distrupts completely. Challenge in deployment, higher costs and slow services. 

## Session Management:
Process of handling a user's interactions with a web application or service

### Stateless:
Server does not store any information about a user's session between requests, treating each interaction as completely new

### Stateful
Server maintains user session data across multiple requests, remembering details like login status or shopping cart items throughout a user's interaction